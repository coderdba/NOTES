=================
KUBERNETES NOTES
=================

https://kops.sigs.k8s.io/boot-sequence/

==============
BOOT SEQUENCE
==============
ETCD - from /etc/systemd/system/etcd.service
API Server, Controller Manager, Scheduler - by kubelet service in /usr/lib/systemd/system/kubelet.service and kubelet.service.d

https://kops.sigs.k8s.io/boot-sequence/
On masters:
kube-apiserver
kube-controller-manager (which runs miscellaneous controllers)
kube-scheduler (which assigns pods to nodes)

Also:
etcd --> If it is created as a pod (not in my case where I start etcd by its service)
dns-controller (like coredns) --> this was created afterwards as a pod - so apiserver/etcd know about it already

On nodes:
kube-proxy (which configures iptables so that the k8s-network will work)

==============
ARCHITECTURE
==============
https://kubernetes.io/docs/concepts/overview/components/

Master Nodes - 'control plane'
- API Server
- Controller Manager
- Scheduler
- ETCD
- Optional - cloud controller manager
- Kubelet (optional) - to start the api server, controller manager and scheduler as pods (if configured so - otherwise, configure those to start as services)

Worker/Node
- Kubelet
- Kube-Proxy

Api-Server
- Kubernetes API
- Can have many instances for HA and load-balancing

ETCD
- KV Pair to keep cluster data

Scheduler
- Assigns nodes to pods based on affinity, resource availability and policies

Controller Manager
- Made of several controllers under the main process
- Node controller: Responsible for noticing and responding when nodes go down.
- Job controller: Watches for Job objects that represent one-off tasks, then creates Pods to run those tasks to completion.
- Endpoints controller: Populates the Endpoints object (that is, joins Services & Pods).
- Service Account & Token controllers: Create default accounts and API access tokens for new namespaces

cloud-controller-manager
- cloud-specific control logic
- Node controller: For checking the cloud provider to determine if a node has been deleted in the cloud after it stops responding
- Route controller: For setting up routes in the underlying cloud infrastructure
- Service controller: For creating, updating and deleting cloud provider load balancers

kubelet
- An agent that runs on each node in the cluster. 
- It makes sure that containers are running in a Pod.
- Takes a set of PodSpecs that are provided through various mechanisms 
- Ensures that the containers described in those PodSpecs are running and healthy. 
- Does not manage containers which were not created by Kubernetes

kube-proxy
- Network proxy that runs on each node in your cluste
- Implementing part of the Kubernetes Service concept
- Maintains network rules on nodes
- Network rules allow network communication to your Pods from network sessions - inside or outside of cluster (inside cluster via local inter-pod dns, externally via services)
- Uses the operating system packet filtering layer if there is one and it's available. Otherwise, kube-proxy forwards the traffic itself

Container runtime
- Software that is responsible for running containers.
- Kubernetes supports several container runtimes: Docker, containerd, CRI-O, and any implementation of the Kubernetes CRI (Container Runtime Interface)

Addons - DNS
- https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/
- https://kubernetes.io/docs/tasks/administer-cluster/dns-custom-nameservers/
- Necessary
- Cluster DNS is a DNS server, in addition to the other DNS server(s) in your environment, which serves DNS records for Kubernetes services.
- Containers started by Kubernetes automatically include this DNS server in their DNS searches
- Example: CoreDNS - with service created as "kube-dns"
- What objects get DNS records? https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/
-- Services
-- Pods

Overlay Network
- https://kubernetes.io/docs/concepts/cluster-administration/addons/
- Like Flannel, Calico


